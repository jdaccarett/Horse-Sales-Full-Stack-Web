// Copyright (c) 2014, 2015 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* Help write the SVG */

(function () {
    "use strict";

    var Tag = require("./svgWriterTag.js"),
        svgWriterUtils = require("./svgWriterUtils.js");

    function SVGWriterFx() {

        var writeSVGFilter = function (ctx, shifted, ele, previousEffect) {
            var attr = {},
                input = ele.input || [],
                children = ele.children || [],
                cur,
                i,
                ii,
                alpha,
                floodOpacity = ele["flood-opacity"];

            attr.result = ele.id;
            if (ele.kind == "filter") {
                attr.id = ele.id;
            }
            floodOpacity = floodOpacity == null ? 1 : floodOpacity;
            for (var prop in ele) {
                if (prop == "input" || prop == "children" ||
                    prop == "kind" || prop == "input" || prop == "id" ||
                    prop == "flood-opacity") {
                    continue;
                }
                if (prop == "flood-color") {
                    // This have to be done because Safari doesn’t
                    // support `rgba()` for `flood-color` yet
                    floodOpacity *= isFinite(ele[prop].alpha) ? ele[prop].alpha : 1;
                    attr[prop] = svgWriterUtils.writeColorNoOpacity(ele[prop], ctx);
                } else {
                    attr[prop] = ele[prop];
                }
            }
            if (floodOpacity < 1) {
                attr["flood-opacity"] = floodOpacity;
            }

            if (shifted) {
                if (typeof attr.x == "number") {
                    attr.x += (ctx._shiftContentX || 0) + (ctx._shiftCropRectX || 0)
                }
                if (typeof attr.y == "number") {
                    attr.y += (ctx._shiftContentY || 0) + (ctx._shiftCropRectY || 0);
                }
            }

            for (i = 0, ii = input.length; i < ii; ++i) {
                if (input[i] != previousEffect) {
                    attr["in" + (i ? "2" : "")] = input[i];
                }
            }
            cur = new Tag(ele.kind, attr);

            for (i = 0, ii = children.length; i < ii; ++i) {
                cur.appendChild(writeSVGFilter(ctx, shifted, children[i], i ? children[i - 1].id : ""));
            }
            return cur;
        },
        writeDropShadowFilter = function (ctx, omIn, dropShadows) {
            var filter = new Tag("filter"),
                attr = {};
            if (omIn.visualBounds) {
                attr.x = omIn.shifted ? omIn.visualBounds.x + (ctx._shiftContentX || 0) + (ctx._shiftCropRectX || 0) : omIn.visualBounds.x;
                attr.y = omIn.shifted ? omIn.visualBounds.y + (ctx._shiftContentY || 0) + (ctx._shiftCropRectY || 0) : omIn.visualBounds.y;
                attr.width = omIn.visualBounds.width;
                attr.height = omIn.visualBounds.height;
                attr.filterUnits = "userSpaceOnUse";
            }
            filter.setAttributes(attr);

            // FIXME: Add support for multiple drop-shadows with blend modes.
            for (var i = 0; i < dropShadows.length && i < 1; ++i) {
                cannedFilters["drop-shadow"](ctx, filter, dropShadows[i]);
            }
            filter.appendChild(new Tag("feComposite", {
                operator: "over",
                in: "SourceGraphic"
            }));
            return filter;
        },
        cannedFilters = {
            "drop-shadow": function (ctx, filter, parameters) {
                var blur = ctx.ID.getUnique("blur");
                filter.appendChild(new Tag("feOffset", {
                    dx: parameters.dx || 0,
                    dy: parameters.dy || 0,
                    input: "SourceAlpha"
                }));
                filter.appendChild(new Tag("feGaussianBlur", {
                    stdDeviation: parameters.r || 0,
                    result: blur
                }));
                // This have to be done because Safari doesn’t
                // support `rgba()` for `flood-color` yet
                var floodOpacity = isFinite(parameters.color.alpha) ? parameters.color.alpha : 1,
                    floodColor = svgWriterUtils.writeColorNoOpacity(parameters.color, ctx);
                filter.appendChild(new Tag("feFlood", {
                    "flood-color": floodColor,
                    "flood-opacity": floodOpacity
                }));
                filter.appendChild(new Tag("feComposite", {
                    operator: "in",
                    in2: blur
                }));
            }
        };

        this.externalizeStyles = function (ctx) {
            var omIn = ctx.currentOMNode,
                filter,
                filterID,
                filterTag;

            if (!omIn.style || !omIn.style.filters || !omIn.style.filters.length) {
                return;
            }
            // Continue to next filter if the current one is bogus.
            // FIXME: For now we just accept one filter and no combination.
            for (var i = 0; i < omIn.style.filters.length; i++) {
                filter = omIn.style.filters[i];
                if (filter.ref) {
                    if (!ctx.svgOM.resources || !ctx.svgOM.resources.filters[filter.ref]) {
                        continue;
                    }
                    filter = ctx.svgOM.resources.filters[filter.ref];
                }
                if (!filter.params) {
                    continue;
                }
                if (filter.type == "dropShadow") {
                    if (!filter.params.dropShadows) {
                        continue;
                    }
                    filterID = ctx.ID.getUnique("filter", ctx.currentOMNode.name);
                    filterTag = writeDropShadowFilter(ctx, omIn, filter.params.dropShadows);
                } else if (filter.type == "svgFilter") {
                    ctx.currentOMNode = filter.params;
                    filterID = ctx.ID.getUnique("filter", ctx.currentOMNode.name);
                    ctx.currentOMNode.kind = "filter";
                    filterTag = writeSVGFilter(ctx, omIn.shifted, ctx.currentOMNode);
                    ctx.currentOMNode = omIn;
                } else {
                    continue;
                }
                filterTag.setAttribute("id", filterID);
                ctx.omStylesheet.def(filterTag, function (def) {
                    ctx.omStylesheet.getStyleBlock(omIn).addRule("filter", "url(#" + ctx.prefix + def.getAttribute("id") + ")");
                });
                break;
            }
        };
    }

    module.exports = new SVGWriterFx;

}());
